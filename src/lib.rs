use near_contract_standards::fungible_token::events::FtMint;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, PanicOnDefault, Promise, PromiseOrValue,
    StorageUsage,
};

const DATA_IMAGE_SVG_GT_ICON: &str = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8yIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTY5LjkxIDE2OS45MSI+PGcgaWQ9IkxheWVyXzEtMiI+PGltYWdlIHdpZHRoPSI4MDAiIGhlaWdodD0iODAwIiB0cmFuc2Zvcm09InNjYWxlKC4yMSkiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBeUFBQUFNZ0NBSUFBQUJVRXBFL0FBQUFDWEJJV1hNQUFEUWJBQUEwR3dGVkRPTnJBQUFnQUVsRVFWUjRuTzNkVVdpYzU1bm84VWszTGNWajZPUkNVZWkyZUNvSW1HSGx6RklMckY2c1psbGQxTDZSRElKMkhZanRpNXIxUXJGMUdtZ0xhUnh2QWlkblNWQzh5K0p6M0FYTGhyaG53UkRwSmo0RmxXaDZzWEt4d3NvUmlKWXU2Z2dPaDhwejBRbDBSQ0UzQjBkWlIxRnNXUm85TTVxWjkvZTdLTGtwU005blNmOTUzKzk3dnljeTN6bVdBUUFnemhmTUVnQWdsc0FDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJOWFhQkF5a3FGL2t3bWs4dnVMeDdvMnppRzUvTGZ5TzNiNzUvR1RsV3FxeXZWZXh2L1Q3TkxIMlF5bWRwYWZhR3kzQkhmQW9SNEl2T2RZeVlKcEtCVTZNLzM5T1o3ZW9jK2pxcjF0S0xGWnBjV2EydC92RnY1M2NMS2NxVzZxcnJvVmdJTDZGcWxRbjh4My9mY2diNWl2bS9UQWhYdFkyRmxlYUd5WEY1YVhQOFBWNGJ1SUxDQXJsTE05NVVLL1NPSEJ5MVFkYUxhV24xMjZZUHkwdUxVbmR1VjZtcnE0NkNUQ1N5ZzQrV3kyVkxoME1qaEk2TURnN2w5V1JlME8xU3FxMVB6dHorT3JiblVaMEVIRWxoQUJ6czFORHd5Y0dUMDhLQ0wyTVZxYS9XcE8zUFQ4N2VWRmgxRVlBR2RwMVRvUHprMGJMMHFOZXRyV3BmZW5iWjdTUHNUV0VESHlHV3pwNGFHengwZHlmZjB1bW9wbTExYXZGYWVtU3pQcEQ0STJwakFBanBBdnFmM3d0aUpVMFBETGhZUDFOYnFsOTZkbml6UFdOQ2lEUWtzb0syVkN2MFh4cDczU0NCYm1DelBYTHg1UTJiUlZnUVcwS2FrRlRzaXMyZ3JBZ3RvTzlLS2hza3Myc1NmWmY3aVdkY0NhQlA1bnQ2SmsyZmVPbm5HYmV3MHBwanZPMzlzNUluTUV3c3J5My82NkNOVFpLOVl3UUxhUWk2YlBYOTA5TUxZQ1plREVMVzErdmkxSzU0MFpLOElMR0R2alE0TVRyendQYXRXaEZ0WVdUNTllY0lyRG1rOVc0VEFYc3IzOUY3OSsvRlh4cDdQWmZlN0VJUjdKdmZVM3cwZnkyWDMvK28vZjIzSGtGWVNXTUNlT1g5czVHZm5mbGc4ME9jUzBGUkhuajM0M1cvOTFkMlY1VXIxbmtuVEdnSUwyQU81YlBiV2oxLzl1K0ZqWC83aWw4eWZGc2hsOTU4YUdyYVVSY3NJTEtEVlJnY0czM3Y1OVlOZi9ackowMkpIbmozNDdlSTNmL1dmdi9sOTdROW1UMU1KTEtDbDdwL0M4TUlaQzFmc2xmVzdzajVjcTkvKzdXOWNCSnBIWUFFdGt1L3BmZS9DNjZPSEJ3MmNQZmZ0NTc1WnpQZjkvTzc3dGd0cEVvRUZ0RUtwMFAvZWhkY2R4RUQ3T1BqVnI5c3VwSGtFRnRCMHA0YUczM254SjdZRmFUZlA1Sjc2N3JlR2Z2WGJYM3U2a0hBQ0MyaXVxMmZ2SDNObHlMU25MMy94UzZlR2hsZXE5eFpXSEVaS0pJRUZORXN1bS8zWnVSOSs5MXRESmt5Ykd4MFl6UGYwVHMvZmRxR0lJckNBcHNobHMrKzkvSHFwY01oNDZRakZmSi9HSXBEQUF1S3QxNVVqMnVrc3hYeGZxWEJvZW43T280WHMzaGZNRUloVnpQZjk3cCt2cWlzNjBmM0hYVjkrUFpmTnVucnNrc0FDSWhYemZmZi9QdTN6OTRsT1ZUelFwN0hZUFlFRmhGRlhkQWVOeGU0SkxDREcrbjFYNm9ydW9MSFlKWUVGQkZCWGRKL2lnYjZyWjhkZFdCcmpLVUpndHp3elNMYzYrTld2Tzd1QnhnZ3NZTGQrZHU2SHpydWlXeFh6ZmJucy9wL2ZmZDhWWmtjRUZyQXJWOCtPTzZ1ZDduYmsyWVBlcGNOT3VRY0xhTnlwb2VGVFE4TUdTTmU3ZW5hOFZPaDNuZGsrZ1FVMHFGVG9kd3N3NlhqbnhaL2tlM3BkY0xaSllBR055UGYwdnZQaVQ0eU9kT1QyWmQ5NThTVUhON0JON3NFQ0d2SGVoZGQ5bWljMXorU2VlaWIzbEljSzJRNHJXTUNPVFp3ODQxQUcwdVMrUTdaSllBRTdNem93ZVA3b2lLR1JySW1UWnl6ZjhsZ0NDOWlCWERicnhuWVN0MzR6VnVwVDRISGNnd1hzd0swZnYzcndxMTh6TVJMM1RPNnBKekpQekM0dHBqNElIczBLRnJCZDU0K05PQW9JMWwwWU8xSE11eE9SUnhKWXdMYmtlM292akQxdlZ2Q0E3WEsyWUlzUTJKYXJmei91eVVIWXlFWWhXN0NDQlR6ZTZNRGc2T0ZCZzRKTkxveWQ4RVFoRHlXd2dNZklaYk1UTDN6UGxPQ2hiQlR5VUFJTGVJenpSMGQ5Um9kSEtSWDZSd2VzNzdLWndBSzJrdS9wUFhmTXNhS3dGVXU4Zko2YjNJR3RUSnc4YytUWmcwWUVXOGhsOTd2Ym5VMnNZQUdQVkNyMGUrMGFiTWU1WXlPNWJOYW9lRUJnQVkvazRDdllwdHkrN1Btam82YkZBd0lMZUxoU29kKzU3YkI5RnJIWVNHQUJEMmY1Q25iRUloWWJDU3pnSVN4ZlFRTXNZdkdBd0FJZXd0RU0wQUNMV0R3Z3NJRE44ajI5WG93RGpmSGhoSFVDQzlqc3d0Z0pNNEhHNVBabEhXNlN2SXpBQWpiTFpiUGUrd0c3WVJFcmVSbUJCV3gyYW1nNHQ4OWR1dEM0NG9FK3o0Z2dzSURQT0hmVWgyL1lyWk4yQ1pNbnNJQlBsUXI5K1o1ZUE0RmR1cjhTN0x5R3RBa3M0Rk0rZGtNVWorSW1UbUFCbjNKN08wUnhxM3ZpQkJid2lkR0JRYmUzUTVUaWdUNGI3aWtUV01BblRnNzlqVkZBb05HQkk4YVpMSUVGZktKVU9HUVVFTWhOalNrVFdFREcvaUEwZzEzQ2xBa3M0TDZSdy9ZeUlKNWR3bVFKTENDemZnS1dPVUM0SVQ5WnFSSllRS2FZdDVFQlRlRTByR1FKTE1EeUZUU1JuNjgwQ1N6QUxnWTBrZWR6MHlTd0FIOEFvSWw4Z0VtVHdJTFVGZk45RG1pQTVyRkZtQ2FCQmFuejJ4K2F6VTlaZ2dRV3BPNjVBMzJwandDYXJKajNVNVljZ1FXcDg2c2ZtczNIbUFRSkxFaGQwYTkrYURJZll4SWtzQ0JwYmcyQkZ2QXhKa0VDQzVMbUFIZG9EWXRZcVJGWWtEU0JCYTNoWnkwMUFndVM5bHorRzZtUEFGckNMbUZxQkJZa0xiZHZmK29qZ0piNFN0Wnh2bWtSV0pBME43bERhMWpCU28zQUFvQ215MW5CU296QWduUjVyQWxheGdwV2FwNU1mUUNRTU85NGZwUktkWFZxL3ZhSDlmckN5bkt0L3NmMi9DTGJUYjZuTjkvVGU2RG42VktoM3hOeklMQUFQcld3c2p4KzdjcnMwcUtaN055blF6czFOSHhoN0lUTTJpVGYwMXVwcnJiVmwwVHoyQ0tFZE5raTNHU3lQUE9YUC95K3V0cTkrNVA4MGZlbjV1YzYvUnVKbGU5NXVwdStIYlltc0NCZHptallhTEk4Yy9yeVJQdDhQWjJ1VnE4ZmYrTTF0VXF5QkJiQS9aMUJkZFVNeDk5OHRiWlc3Nzd2Q3g1TFlBRmt4cTlkTVlSbXFOWHJsOTZkN3I3dkN4NUxZQUdwcTFSWDdXUTF6MXUzcHJyMVc5c3BkejBtUldBQnFadWF2NTM2Q0pxcFZxL3IxM1h1ZWt5S3dBSlM5MkhkVFVMTlZWdHpsaGpKRVZnQU5OZmR5dTlNbU5RSUxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDUFdtZ2tLelpwUTh5TjEzK2orY0FFRXBnUWJwbWx4Wm5seGI5QXdBSVo0c1FBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNEWWt3Wktta3FGL28zZmQ3Nm5OOS9UMndXVG1DelBWS3FyYmZDRkFDUk5ZTkhOY3RsczhVQmZNZCtYMjdkLzZPT2krdmkvczEzOExjOHVmU0N3QVBhY3dLS3I1SHQ2UzRYKzUvSjkvOVZWM2R4U0FMUXRnVVhISytiN1NvWCtvVUovcVhCSVVRSFFEZ1FXSFNtWHpaWUtoMFlPSHlrVitydmozaWtBdW9uQW9wUGtzdG5SdzRNakEwZEdEdys2Y0FDMExZRkZaeGdkR0J3NWZPVFUwTERyQlVEN0UxaTB0WHhQNzdsakk2T0hqOWdIQktDRENDemFWS25RLzNGYTJRb0VvUE1JTE5yT3FhSGhDMk1uTEZrQjBMa0VGbTFFV2dIUUhRUVdiVUZhQWRCTkJCWjdyRlRvdjNwMlhGb0IwRTBFRm51bW1PK2JlT0hNcHBjdUEwQVhFRmpzZ1Z3MmUySHMrZk5IUnd3ZmdLNGtzR2kxMFlIQmlSZStaMDhRZ0M0bXNHaWRYRFo3OWV5NG82MEE2SG9DaXhZWkhSaThlblk4dHk5cjRBQjBQWUZGMCtXeTJZa1h6bmlOSUFEcEVGZzBWekhmOTg0UFhuTEhGUUJKRVZnMDBmbGpJeE12bkRGaEFGSWpzR2dLMjRMQUEwT091eU05QW90NCtaN2VkMTU4cVhpZ3oyeUI5VTljeGtCcUJCYkJpdm0rOTE1KzNkT0N3THA4VDYrUFcrc3ExZFYyK0RKb0RZRkZwRk5Ed3hNbno2Z3I0SUVMWXljTVk1M0FTb3JBSXN5cG9lR3JaOGZORTNpZ21POXpMeVpwRWxqRWVHWHNlWjlUZ1kxeTJldzdQM2pKU0VpVHdDTEExYlBqUHFRQ0d6a0RqOFFKTEhaTFhRRWI1WHQ2TDR5ZDhHdmg4eFpXbHR2dFM2SjVCQmE3b3E0Z3hDdGp6M2Y2SUEvMFBKM3Y2YzEvL0w5dDhPVzBvMXE5bnZvSVVpS3dhSnk2Z2lodVlZUXU4d1VYbE1hOE12YTh1Z0xZcHRtbFJhTktpc0NpRWFlR2huM2dCb0JIRVZqc21QT3VBSGFxYkFVck1RS0xuU25tK3laT25qRTBBTmlDd0dJSDhqMjkzak1JMElEWnBRK01MU2tDaSsyNmZ5anppeStwSzRBR1ZLcjNqQzBwQW92dG1uamhqRmZpQXpUR201NVRJN0RZbHZQSFJoektBTkFZWnpRa1NHRHhlUGR2YkgvQmplMEFEZktTbkFRSkxCN0QrL0FCZHVsdVJXQWxSMkR4R0ZmUGpudXpHTUJ1V01GS2tNQmlLNk1EZzZPSEI0MElvR0cxdGZxQ0ZhejBDQ3dlS1pmTk9yRWRZSmVjZ0pVbWdjVWpYVDA3N3RRcmdGM3lrcHcwQ1N3ZXp1WWdRQWhuTktSSllQRVFOZ2NCUXJnQksxa0NpNGU0TVBhOHpVR0EzWnU2TTJlS2FSSlliRmJNOTUwL09tSXNBTHZuQnF4a0NTdzJjMmc3UUpTcGVTdFlpUkpZZk1ib3dHQ3AwRzhtQUxzM05UOVhxOWNOTWswQ2k4K1llT0Y3QmdJUVl2ck9iWU5NbHNEaVU2ZUdocjBWQnlDSy9jR1VDU3crZFdIc2hHa0FoTEEvbURpQnhTY3NYd0VFdWxiK2hYR21UR0R4Q2N0WEFGRnFhM1VuWUNWT1lKR3hmQVVRYTdJOFk2S0pFMWhrTEY4QnhMcjA3clNKSms1Z2tTa1YraTFmQVVTWm1wK3JWRmVOTTNFQ2k4eTVZMTZNQXhERzhsWHlNZ0tMVEw2bmQvVHdvRGtBaEtoVVYyZTlmeENCaGVVcmdFQVhiOTR3enVSbEJCYjNueDgwQklBUWxlcXE1d2RaSjdDU05qb3dtTnVYVFgwS0FFRXNYL0dBd0VyYXlhRy9TWDBFQUVFc1g3R1J3RXBYTHB0MWV6dEFGTXRYYkNTdzBxV3VBS0pZdm1JVGdaV3VrWUVqcVk4QUlNajQ5WjhhSlJzSnJFVFpId1NJTXJ1MDZOWE9iQ0t3RXFXdUFLS01YNzlpbG13aXNCSTFWT2hQZlFRQUVkNjZOYjFRV1RaS05oRllpUm9kc0lJRnNGdTF0ZnJGbTI4Ykk1OG5zRkpVelBjNVh4Umc5MDVmbnFqVjZ3Yko1d21zRkpYc0R3THMydFQ4bkh2YmVSU0JsU0kzWUFIc1VtMnRmdnJ5aENueUtBSXJSYVhDb2RSSEFMQTdOZ2ZabXNCS2podXdBSFpwc2p4amM1Q3RDYXprRkEvMHBUNENnRjJvVkZjZGZNVmpDYXprUEpjWFdBQ05PLzdtYXpZSGVTeUJsUndyV0FBTkc3OSt4YkdpYklmQVNvNHpHZ0FhTTFtZWVldmRhY05qT3dSV1d2STl2YW1QQUtBaEN5dkxicjFpK3dSV1d2STlUNmMrQW9DZHE2M1YvL29mZnVUV0s3WlBZS1hGQ1ZnQU82V3VhSURBQW9DdGpGOXpZenM3SnJEUzRpVTVBRHR5K3ZMRVpIbkd6TmdwZ1FVQUQzZng1ZzExUldNRVZscWMwUUN3VFpQbG1WZHV2bTFhTk9aSmM0UDFkMTlVcXZjcTFkV1Y2cjJPbmtlbHc3OSthQk9UNVpuVGx5ZGNEUm9tc0JLU3kzckg4ME5NbG1jdTNyeFJxYTYyM1ZjRzdCRjF4ZTRKcklSNFNjNG1sZXJxOFRkZjgzQVFzSkc2SW9UQUlsR1Y2dXBmL3VqN0RyWUJOcnA0ODRiN3JnZ2hzRWlVOStFRG16aVJnVUFDaXhSTmxtZnNEQUlQMU5icTQ5ZXVxQ3NDQ2F5RWVOUHpBeGR2M21pVHJ3VFljK3R2d3ZHaGkxZ0NLeUVDYTkzQ3lySm5Cb0YxQ3l2TDNqTklNd2dza3VNM0tiQnVzand6ZnYySzN3azBnOEFpT2VXbFJSY2RHTDkrNWExM3A1TWZBODBpc0FCSWl6UHdhQUdCQlVCQ2JBdlNHZ0lMZ0NUVTF1cW5MMDlNM1psenVXa0JnUVZBOTV1YW56dDllY0xDRlMwanNBRG9acFhxNnZqMW4xcTRvc1VFRmdCZDY2MWIweGR2dm0zaGl0WVRXQUIwb2RtbHhkT1hKNXdxekY0UldBQjBsVXAxOWZUbGlWa24zckduQkJZQVhhSlNYYjE0ODRaM050TU9CQllBSFU5YTBXNEVGZ0FkYkdGbCtkSzcwOUtLZGlPd0FPaElVL056bDk2ZGRxOFY3VWxnQWRCSkt0WFZhK1ZmVEpablBDRklPeE5ZQUhTR3lmTE05UHh0UjRiU0VRUVdBRzF0YW41dStzN3RxZms1NTRYU1FRUVdBRzJuVWwyZFhWcWNucjg5dS9TQnJxSVRDU3dBMmtKdHJUNjc5RUY1YVhGMmFYR2hzdXlpME5FRUZnQjdvN1pXWDZnc0w2d3MzNjBzenk0dHVtbWRiaUt3QUdpNjlaYktaRExscGNYYTJoL1h1OHJlSDExTVlBSHN2WXMzYjNUSFZhaFVWemN0UkRtbmlqUUpMSUM5OThyTnQxMEY2Q1pmY0RVQkFHSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUk5YWFCQXJGS2h2MVE0bFBoUUs5WFZ5ZkpNRzN3aHdONFFXRUN3VXVIUWhiRVRpVTkxZG1sUllFSEtiQkVDeEN2bSswd1ZVaWF3QU9MbDltVk5GVkltc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FKb2lueFByOEZDc2dRV1FGUGtlNTQyV0VpV3dBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0FndWdLWExaL1FZTHlSSllBRTFSUE5CbnNKQXNnUVVBRUV4Z0FRQUVFMWdBQU1FRUZnQkFNSUVGQUJCTVlBRUFCQk5ZQUFEQkJCWUFRRENCQlFBUVRHQUJBQVFUV0FBQXdRUVdBRUF3Z1FVQUVFeGdBUUFFRTFnQUFNRUVGZ0JBTUlFRkFCQk1ZQUVBQkJOWUFBREJCQllBUURDQlJYSU85RHp0b2dQUVZBS0w1T1I3ZWwzMHB2cEtOdHZGM3gzQWRnZ3NrbE1xOU9jVVFET05IajdTdmQ4Y3dMWUlySVRNTG4yUStnait5L21qbyszeGhYU2hVcUhmR2lHQXdDSkY1NDZOV01ScWtvbVRaN3J5K3dMWUVZRkZpbkw3c3UvODRDY3VmYmlyWjhlTEIvcTY3SnNDYUlEQUlsR2xRdjg3TDc1a0hTdlExYlBqcDRhR3UrYmIyYjNhMmg4Ny9Wc0FHaWF3RWxLcDNrdDlCSjgxZW5qd1AxNy9aMDJ3ZTZWQy8zLzhENVBjYktHeTNGNWZFTkJDVHhwMk9pclYxZFJIOERuNW50NnJaOGN2akoyWVhWcGNxZDViV0ZtdTFhMDZiRmVwY09ncjJlem80U1B1YWdmWVJHREIvY3c2TlNRUkNGWmJxeHNwSk1zV1lWb1dWdXhaUUl2WUlvU1VDYXkwMU9vK1VnTkEwd21zdEZqQmd0YVlYVm8wYVVpWndFckxoMWF3b0NXYzBRQ0pFMWhwc1lJRnJYRzM4anVUaHBRSnJMUTRxUUZhdzg4YUpFNWdwY1ZqVGRBYUFnc1NKN0NTWTVjUVdzQk43cEE0Z1pVY2kxalFiRDdHQUFJck9YZjk2b2NtOHpFR0VGako4YXNmbXMzSEdFQmdKY2V0SWRCc2Zzb0FnWlVpdi8yaGVXcHJkZXZFZ01CS1VWbGdRZFBNTG4xZ3VJREFTcEUvQU5BOFBzQkE4aklDSzFHMkNLRjUvSHhCOGpJQ0sxMVQ4M09wandDYW9GSmRkUU1XSkM4anNOSmxGd09hd2ZJVnNFNWdKV3JxenUzVVJ3Qk5NRDN2Snd2SUNLeDAzZC9JY0JZaWhLcXQxYWZ1Mkh3SE1nSXJhZGZLTTZtUEFFSjVQaGQ0UUdDbHl5NGh4THBXL29XSkF1c0VWcnJzRWtJZys0UEFSZ0lyYVpmZW5VNTlCQkJFWFFFYkNheWtPUTBMb3JpcEVkaElZQ1d0VnE5UCtxc0F1MWFwcmpvQkM5aElZS1hPeDI3WXZVdTM3TFlEbnlHd1VqZTd0RmlwcnFZK0JkaUYycHFWWUdBemdVWG00czBiaGdBTm03b3pWNnZYelEvWVNHQ1JtU3pQMU5iOGVZQUcrWWdDZko3QUl1TzhCbWpZMVB5Y1RYYmc4d1FXOTcxMWE4b2lGalRBaHhQZ29RUVdtZlh6R3Z5ZGdKMmFYVnAwT2dQd1VBS0xUMWpFZ3AyNmVQTnRNd01lU21EeENZdFlzQ09XcjRBdENDdytaUkVMdHMveUZiQUZnY1duTEdMQk5rMldaeXhmQVZzUVdIekdLemZmOXN3NWJLMjJWbmYyRmJBMWdjVm00OWQvYWlhd2hVdnZUdnNjQW14TllMSFoxSjA1ZXgvd0tKWHE2bHUzcG93SDJKckE0aUZPWDU0d0ZuaW84ZXMvOWVaQjRMRUVGZzlScWE2NnhRUStiMnArYnVyT25NRUFqeVd3ZUxoWGJyNjlzTEpzT1BCQWJhMCtmczBkaXNDMkNDd2V5VVloYkhUUk03YkF0djFaNWkrZU5TMGU2dmUxUHp5UmVhSlU2RGNlbUYxYVBQdXYvNUw4R0lEdHNvTEZWbXdVd3ZybTRQRTNYelVKWVBzRUZvOXgrdktFOStlUXVQcy9CWjRjQkhaQ1lQRVlDNVhsOFd0WFRJbGt2WFZyMnBPRHdFNjVCNHZIVzFoWnp2ZjBGdk45WmtWcUZsYVdqNy94bXNzTzdKUVZMTFpsL1BvVk4yT1JtdnUzWHFrcm9DRUNpMjJwMWUvL3BYRXpGa2s1L3NhcnptVUFHaU93Mks1S2RmWDRHeDZrSWhXbkwwOTRLU2ZRTUlIRkRzd3VMVHA5bEJSTWxtY215ek11TmRBd043bXpNd3NyeTducy9pUFBIalEzdXRYVS9OemYvdE0vdXJ6QWJnZ3NkdXpuZDkvM1VDSGQ2djVqZzIrKzlxZVBQbktGZ2Qyd1JVZ2ozSjVDVjFwWVdmN3JmL2lSTTBXQjNSTllOT2o0bTY4NnVJRnVVbHVycXlzZ2lzQ2lRYlg2L2I5R0dvdnVvSzZBV0FLTHhta3N1c042WFMxVS9Fc0d3Z2dzZGtWajBlblVGZEFNQW92ZFdtOHM5N3pUaVJaV2xyL3gvZFBxQ2dqbm1BWUMvT21qajY2Vlo1emRRR2Z4ekNEUVBBS0xNTlB6dHpVV25XSjJhZkhvNnkrcks2QkpCQmFScHVkdnIxVHZqUTRNbWlydGJMSTg0elJSb0trRUZzRVdWcGJ2cnZ6dTI4VnZmdm1MWHpKYjJ0RDQ5U3MvL3Rta0t3TTBsY0FpM3EvLzMvLzkrZDMzanp4NzhKbmNVOFpMKzZpdDFZLys5NWYvOTcvLzBqVUJtazFnMFJTL3IvM2gzK1orZWZEUHYzYndxMTgzWWRyQng3ZTAvOWlSSWtCckNDeWE1VThmZmZSdi8vN0xEOWZxMzM3dW00Yk0zbnJyMXZUeE4xNnJyYm1sSFdnUmdVVnozZjd0YjZibmI5c3VaSy9VMXVwLyswLy9lT25kYVZjQWFDV0JSZE90YnhkKytVdGZPdkxzUWRPbWxXYVhGZ2QvOHQrY0l3cTBuc0NpRmY3MDBVYy92L3QrZVdteFZPalBaZmViT2MxV1c2di8rR2VUWi8vMVg1ekZBT3dKZ1VYclZLcjNydjF5eGxJV3pUWTFQM2Y4amRmK3o5MzNUUnJZSzA5a3ZuUE04R214VXFGLzR1U1o0Z0ZudmhPc1VsMGR2LzdUcVR0ekJndnNMU3RZN0lGSzlkNy9tcm4xNFZyOXlMTUhuVWRLbElzM2I1eitueFB1dUFMYWdSVXM5bEl1bXoxL2RQVEMyQWxYZ2QyWUxNOWN2SG1qVWwwMVJhQk5DQ3oyWHI2bjk4TFlpVk5EdzY0Rk96Vzd0SGp4NXR1elM0c21CN1FWZ1VXN2tGbnNpTFFDMnBuQW9yM0lMQjVMV2dIdFQyRFJqdkk5dmFlR2hzOGRHOG50eTdwQVBPQmVLNkJUQ0N6YTJucG1PZEFoY1pYcTZxVmIwNVBsbVZyZHl3U0J6aUN3NkFERmZOL0pvZUZUUThNV3RKSlNXNnRQM1ptN1ZwNnhHd2gwSElGRkp4a2RHQnc1ZkdSMFlGQnBkYmVwK2JucE83ZW41dWNzV1FFZFNtRFJrVVlIQm9jSy9hT0hqK1I3ZWwzQjdyQytYalU5ZjN0MjZRTmRCWFE2Z1VWbnkvZjBqZzRjR1NyMGx3cUhMR3Qxb3RtbHhmTFM0dFQ4bkJQWWdXNGlzT2dleFh4ZjhVRGZVS0YvL1Q5YzJmWlVxYTR1ckN5WGx4WVhLc3R1cmdLNmxjQ2lhNjFuVnI2bjk3bjhOM0w3OXBjSy9hNTE2eTJzTE5mcTlmTFNZcVc2V3FtdUtpb2dFUUtMdEJUemZlczdpYVhDb1kzZitKRDhhbFQ1czgzMGNWSDljWDN2cjZPK0Q0QklBZ3NBSU5nWERCUUFJSmJBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zUG52b05jQUFBR0lTVVJCVkFBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQ0NDU3dBZ0dBQ0N3QWdtTUFDQUFnbXNBQUFnZ2tzQUlCZ0Fnc0FJSmpBQWdBSUpyQUFBSUlKTEFDQVlBSUxBQ0NZd0FJQUNDYXdBQUNDQ1N3QWdHQUNDd0FnbU1BQ0FBZ21zQUFBZ2drc0FJQmdBZ3NBSUpqQUFnQUlKckFBQUlJSkxBQ0FZQUlMQUNDWXdBSUFDQ2F3QUFDQ0NTd0FnR0FDQ3dBZ21NQUNBQWdtc0FBQWdna3NBSUJnQWdzQUlKakFBZ0FJSnJBQUFJSUpMQUNBWUFJTEFDQ1l3QUlBQ0Nhd0FBQWlaVEtaL3crcHhQNGF5VzdCbUFBQUFBQkpSVTVFcmtKZ2dnPT0iLz48L2c+PC9zdmc+";

/// The specific version of the standard we're using
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    owner: AccountId,
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct OldContract {
    /// Keep track of each account's balances
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of all tokens.
    pub total_supply: Balance,

    /// The bytes for the largest possible account ID that can be registered on the contract
    pub bytes_for_longest_account_id: StorageUsage,

    /// Metadata for the contract itself
    pub metadata: LazyOption<FungibleTokenMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        // Calls the other function "new: with some default metadata and the owner_id & total supply passed in
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "WALC".to_string(),
                symbol: "WALC".to_string(),
                icon: Some(DATA_IMAGE_SVG_GT_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(owner: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        require!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();

        let mut token = FungibleToken::new(StorageKey::Accounts.try_to_vec().unwrap());

        token.internal_register_account(&owner);
        token.internal_deposit(&owner, total_supply.into());

        FtMint {
            owner_id: &owner,
            amount: &total_supply,
            memo: Some("Initial token supply is minted"),
        }
        .emit();

        Self {
            owner,
            token,
            metadata: LazyOption::new(StorageKey::Metadata.try_to_vec().unwrap(), Some(&metadata)),
        }
    }

    pub fn migrate(&mut self) {
        require!(
            env::predecessor_account_id() == self.owner,
            "Only account owner can update the code"
        );
        // 5 billion total supply.
        // The total supply didn't get migrated properly, so need to fix it here.
        self.token.total_supply = 5_000_000_000_000_000_000_000_000_000_000_000;
    }

    pub fn upgrade(&self) -> Promise {
        require!(
            env::predecessor_account_id() == self.owner,
            "Only account owner can update the code"
        );

        let code = env::input().expect("Error: No input").to_vec();

        Promise::new(env::current_account_id())
            .deploy_contract(code)
            .then(Self::ext(env::current_account_id()).migrate())
            .as_return()
    }
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name: "WALC".to_string(),
            symbol: "WALC".to_string(),
            icon: Some(DATA_IMAGE_SVG_GT_ICON.to_string()),
            reference: None,
            reference_hash: None,
            decimals: 24,
        }
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token);
